1. 3 because the var keyword is being used
2. 150 because the var keyword is being used to assign discountedPrice so it is accessible outside of the for loop
3. 150 because var was used when the finalPrice was assigned
4. [ 50, 100, 150 ] because those are the discounted prices
5. ReferenceError: i is not defined because i is not accessible outside of the block due to the let keyword
6. ReferenceError: discountedPrice is not defined discountedPrice is not accessible outside of the block due to the let keyword
7. 150 because finalPrice was defined outside of the block and is accessible by line 14
8. [ 50, 100, 150 ] discounted is defined outside of the block so it returns the discounted prices
9. ReferenceError: i is not defined i is not accessible outside of the block due to the let keyword
10. 3 because length is defined once outside of the block
11. [ 50, 100, 150 ] because const keyword is being used 
12. A) student.name;
    B) student['Grad Year']
    C) student.greeting()
    D) student['Favorite Teacher'].name;
    E) student.courseLoad[0]
13. A)32 because the '+' operator can be used to concatenate strings so the second number is type cast
    B) 1 because '-' is used numerically so the first number is type cast
    C) 3 because null is converted to 0 when referring to numbers
    D)'3null' because '+' is used for string concatenation and the 3 is of the string data type.
    E) 4 becuase true is equivalent to 1 in numerical terms
    F) 0 because false and null both equate to 0
    G) '3undefined' because the '+' operater concatenates the strings and the first term is of a string data type
    H) 'NaN' because the '-' operator is used only numerically and undefined cannot be type cast to an numerical value
14. A) True because they are both converted to     numbers and the comparison is true
    B) True because they are both converted to numbers and the numerical value of 2 is less than 12
    C) True because the '==' operator compares the value of the two terms once they are the same data type. 
    D) False because '===' does not type cast them so it returns false even when the data types are different
    E) False because true will be converted to 1 but 1 is not equal to 2
    F) True because Boolean(2) will be true and true == true
15. The == operator will compare two terms while converting them to the same data types if possible. The === operator is more strict and will not modify the two terms in any way before comparing them. 
16. Code
17. [2,4,6] because the do Something function will be applied to each element before it is returned
18. Code
19. 1 4 3 2
